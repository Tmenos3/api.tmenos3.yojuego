 var CommonValidatorHelper = require('../helpers/CommonValidator/CommonValidatorHelper');
 var NotNullOrUndefinedCondition = require('../helpers/CommonValidator/NotNullOrUndefinedCondition');
 var CustomCondition = require('../helpers/CommonValidator/CustomCondition');
 var config = require('../../config');
 var moment = require('moment');
 var mongo = require('mongodb')

var profile = {
    get: (userId) => {},
    update: () => {}
}

var invitations = {
    getAll: (userId) => {},
    getPending: (userId) => {},
    getSended: (userId) => {},
    create: () => {},
    accept: (invitationId) => {},
    reject: (invitationId) => {},
    remove: (invitationId) => {}
}

var friends = {
    getAll: (userId) => {},
    accept: (userId, acceptedUserId) => {},
    invite: (userId, invitedUserId) => {},
    remove: (userId, removedUserId) => {}
}

var groups = {
    getAll: (userId) => {},
    inviteTo: (userId, groupId, userToInviteId) => {},
    joinTo: (userId, groupId) => {},
    remove: (userId, groupId) => {},
    create: () => {}
} 

var matches = {
    getAll: (userId) => {},
    getNextMatches: (userId) => {},
    getPastMatches: (userId) => {},
    remove: (matchId) => {},
    create: () => {}
}  

class ApiService{
    constructor(repo, jwt){
        var conditions = [
            new NotNullOrUndefinedCondition(repo, ApiService.INVALID_REPOSITORY()),
            new NotNullOrUndefinedCondition(jwt, ApiService.INVALID_JWT()),
        ];
        
        var validator = new CommonValidatorHelper(conditions, () => {
            this._repo = repo; 
            this._profile = profile;
            this._invitations = invitations;
            this._friends = friends;
            this._groups = groups;
            this._matches = matches;
            this._repo = repo; 
            this._jwt = jwt;
        }, (err) => { throw new Error(err); });

        validator.execute();
    }

    login(req){
        return new Promise((resolve, reject) => {
            var conditions = [
                new CustomCondition(() => { return this._isValidRequest(req); }, ApiService.INVALID_REQUEST()),
                new CustomCondition(() => { return this._isValidRequestBody(req); }, ApiService.INVALID_REQUEST_BODY()),
                new CustomCondition(() => { return this._isValidUsername(req); }, ApiService.INVALID_CREDENTIALS()),
                new CustomCondition(() => { return this._isValidPassword(req); }, ApiService.INVALID_CREDENTIALS())
            ];
            
            var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateLogin(req.body.username, req.body.password, resolve, reject) }, (err) => { reject(err); });
            validator.execute();
        });
    }


    signUp(req){
        return new Promise((resolve, reject) => {
            var conditions = [
                 new CustomCondition(() => { return this._isValidRequest(req); }, ApiService.INVALID_REQUEST()),
                 new CustomCondition(() => { return this._isValidRequestBody(req); }, ApiService.INVALID_REQUEST_BODY()),
                 new CustomCondition(() => { return this._isValidUsername(req); }, ApiService.INVALID_CREDENTIALS()),
                 new CustomCondition(() => { return this._isValidPassword(req); }, ApiService.INVALID_CREDENTIALS())
            ];
            
            var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateSignUp(req.body.username, req.body.password, resolve, reject) }, (err) => { reject(err); });
            validator.execute();
        });
    }

    getUserProfile(req){
        return new Promise((resolve, reject) => {
            this._verifyAuthentication(req)
            .then((ret) => {
                var conditions = [
                    new CustomCondition(() => { return this._isValidIdUser(ret.id); }, ApiService.UNAUTHORIZED())
                ];
                var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateGetUserProfile(ret.id, resolve, reject) }, 
                                                                     (err) => { reject({ status: false, code: 401, message: err}); });
                validator.execute();
            }, (ret) => reject(ret))
            .catch((err) => reject(err));
        });
    }

    getUpcomingMatches(req){
        return new Promise((resolve, reject) => {
            this._verifyAuthentication(req)
            .then((ret) => {
                var conditions = [
                    new CustomCondition(() => { return this._isValidRequestParams(req); }, ApiService.INVALID_REQUEST_PARAMS()),
                    new CustomCondition(() => { return this._isValidIdUser(ret.id); }, ApiService.UNAUTHORIZED()),
                    new CustomCondition(() => { return this._isValidDatefrom(req); }, ApiService.INVALID_DATEFROM())
                ];
                var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateGetUpcomingMatches(ret.id, req.params.datefrom, resolve, reject) }, 
                                                                     (err) => reject({ status: false, code: 400, message: err}));
                validator.execute();
            }, (ret) => reject(ret))
            .catch((err) => reject(err));
        });
    }

    _doAfterValidateLogin(username, password, resolve, reject){
        this._repo.getOne('users', {username: username})
            .then((userReturned) => { 
                if (userReturned.password === password){
                    var token = this._jwt.sign({id: userReturned._id, username: userReturned.username, password: userReturned.password}, config.secret, { expiresIn: config.expiresIn });
                    resolve({ status: true, token: token });
                }else{
                    reject({ status: false, message: ApiService.INVALID_CREDENTIALS() });
                }
             }, 
             (err) => { reject({ status: false, message: err }); })
            .catch((err) => { reject({ status: false , message: err}); });
    }

    _doAfterValidateGetUserProfile(idUser, resolve, reject){
        this._repo.getOne('users', {_id: idUser})
            .then((userReturned) => { 
                if (userReturned === undefined || userReturned === null){
                    reject({ status: false, code: 401, message: ApiService.UNAUTHORIZED() });
                }else{
                    resolve(userReturned.profile);
                }
             }, 
                  (err) => { reject({ status: false, message: err }); })
            .catch((err) => { reject({ status: false , message: err}); });
    }

    _doAfterValidateSignUp(username, password, resolve, reject){
        this._repo.getOne('users', {username: username})
            .then((userReturned) => { 
                        if(userReturned !== null && userReturned !== undefined){
                            reject({ status: false, message: ApiService.USERNAME_IS_ALREADY_IN_USE() });
                        }else{
                            this._repo.insert('users', {username: username, password: password});
                            resolve(ApiService.USER_CREATED());
                        }
                    }, 
                  (err) => { reject({ status: false, message: err }); })
            .catch((err) => { reject({ status: false , message: err}); });
    }

    _doAfterValidateGetUpcomingMatches(idUser, datefrom, resolve, reject){
        this._repo.getOne('players', {_idUser: new mongo.ObjectId(idUser)})
            .then((playerReturned) => {
                if (playerReturned === undefined || playerReturned === null){
                    reject({ status: false, code: 401, message: ApiService.UNAUTHORIZED() });
                }else{
                    this._repo.getBy('matches', { datetime: {$gte: new Date(datefrom).toISOString()}, confirms: [playerReturned._id]})
                    .then((matchesReturned) => resolve(matchesReturned), (err) => reject(err))
                    .catch((err) => reject(err));
                }
             }, 
                  (err) => reject({ status: false, message: err }))
            .catch((err) => reject({ status: false , message: err}));
    }

    _isValidRequest(req){
        return !(req === undefined || req === null);
    }

    _isValidRequestHeader(req){
        return !(req.headers === undefined || req.headers === null);
    }

    _isValidRequestBody(req){
        return !(req.body === undefined || req.body === null);
    }

    _isValidAuthorization(req){
        return !(req.headers.authorization === undefined || req.headers.authorization === null);
    }

    _verifyAuthentication(req){
        return new Promise((resolve, reject) => {
            var conditions = [
                 new CustomCondition(() => { return this._isValidRequest(req); }, ApiService.INVALID_REQUEST()),
                 new CustomCondition(() => { return this._isValidRequestHeader(req); }, ApiService.INVALID_REQUEST_HEADER()),
                 new CustomCondition(() => { return this._isValidAuthorization(req); }, ApiService.UNAUTHORIZED())
            ];
            
            var validator = new CommonValidatorHelper(conditions, () => { 
                this._jwt.verify(req.headers.authorization, config.secret, (err, decoded) => {
                    if(err){
                        reject({ status: false, code: 401, message: ApiService.UNAUTHORIZED()});
                    }else{
                        resolve(decoded);
                    }
                });
             }, (err) =>  reject({ status: false, code: 401, message: err}));
            validator.execute();
        });
    }

    _isValidUsername(req){
        return !(req.body.username === undefined || req.body.username === null);
    }

    _isValidPassword(req){
        return !(req.body.password === undefined || req.body.password === null);
    }

    _isValidRequestParams(req){
        return !(req.params === undefined || req.params === null);
    }

    _isValidDatefrom(req){
        return (!(req.params.datefrom === undefined || req.params.datefrom === null)) && moment(req.params.datefrom, [moment.ISO_8601], true).isValid();
    }

    _isValidIdUser(idUser){
        return !(idUser === undefined || idUser === null);
    }

    static UNAUTHORIZED(){
        return 'Unauthorized';
    }

    static INVALID_REQUEST(){
        return 'Request inválido';
    }

    static INVALID_REQUEST_PARAMS(){
        return 'Los parámetros del request no son válidos.';
    }

    static INVALID_REQUEST_HEADER(){
        return 'EL header no es válido.';
    }

    static INVALID_REQUEST_BODY(){
        return 'Body request inválido';
    }

    static INVALID_REPOSITORY(){
        return 'El password es inválido';
    }

    static INVALID_JWT(){
        return 'El jwt es inválido';
    }

    static INVALID_CALLBACK(){
        return 'Callback inválido.';
    }

    static INVALID_CREDENTIALS(){
        return 'Las credenciales no son válidas.';
    }

    static USERNAME_IS_ALREADY_IN_USE(){
        return 'El nombre de usuario ya está siendo utilizado.';
    }

    static INVALID_ID_USER(){
        return 'El id de usuario es inválido.';
    }

    static USER_CREATED(){
        return 'El usuario ha sido creado.';
    }

    static USER_DOES_NOT_EXIST(){
        return 'Usuario inexistente.';
    }

    static INVALID_DATEFROM(){
        return 'El parametro datefrom debe existeir en el request.params';
    }
}

module.exports = ApiService;