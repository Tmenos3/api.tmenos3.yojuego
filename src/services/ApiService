 var CommonValidatorHelper = require('../helpers/CommonValidator/CommonValidatorHelper');
 var NotNullOrUndefinedCondition = require('../helpers/CommonValidator/NotNullOrUndefinedCondition');
 var CustomCondition = require('../helpers/CommonValidator/CustomCondition');
 var config = require('../../config');
 var moment = require('moment');
 var ObjectId = require('mongodb').ObjectId;

class ApiService{
    constructor(UserMap, PlayerMap, MatchMap, jwt){
        var conditions = [
            new NotNullOrUndefinedCondition(UserMap, ApiService.INVALID_USERMAP()),
            new NotNullOrUndefinedCondition(PlayerMap, ApiService.INVALID_PLAYERMAP()),
            new NotNullOrUndefinedCondition(MatchMap, ApiService.INVALID_MATCHMAP()),
            new NotNullOrUndefinedCondition(jwt, ApiService.INVALID_JWT()),
        ];
        
        var validator = new CommonValidatorHelper(conditions, () => {
            this._UserMap = UserMap;
            this._PlayerMap = PlayerMap;
            this._MatchMap = MatchMap; 
            this._jwt = jwt;
        }, (err) => { throw new Error(err); });

        validator.execute();
    }

    login(req){
        return new Promise((resolve, reject) => {
            var conditions = [
                new CustomCondition(() => { return this._isValidRequest(req); }, ApiService.INVALID_REQUEST()),
                new CustomCondition(() => { return this._isValidRequestBody(req); }, ApiService.INVALID_REQUEST_BODY()),
                new CustomCondition(() => { return this._isValidUsername(req); }, ApiService.INVALID_CREDENTIALS()),
                new CustomCondition(() => { return this._isValidPassword(req); }, ApiService.INVALID_CREDENTIALS())
            ];
            
            var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateLogin(req.body.username, req.body.password, resolve, reject) }, (err) => { reject(err); });
            validator.execute();
        });
    }

    signUp(req){
        return new Promise((resolve, reject) => {
            var conditions = [
                 new CustomCondition(() => { return this._isValidRequest(req); }, ApiService.INVALID_REQUEST()),
                 new CustomCondition(() => { return this._isValidRequestBody(req); }, ApiService.INVALID_REQUEST_BODY()),
                 new CustomCondition(() => { return this._isValidUsername(req); }, ApiService.INVALID_CREDENTIALS()),
                 new CustomCondition(() => { return this._isValidPassword(req); }, ApiService.INVALID_CREDENTIALS())
            ];
            
            var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateSignUp(req.body.username, req.body.password, resolve, reject) }, (err) => { reject(err); });
            validator.execute();
        });
    }

    getUserProfile(req){
        return new Promise((resolve, reject) => {
            this._verifyAuthentication(req)
            .then((ret) => {
                var conditions = [
                    new CustomCondition(() => { return this._isValidIdUser(ret.id); }, ApiService.UNAUTHORIZED())
                ];
                var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateGetUserProfile(ret.id, resolve, reject) }, 
                                                                     (err) => { reject({ status: false, code: 401, message: err}); });
                validator.execute();
            }, (ret) => reject(ret))
            .catch((err) => reject(err));
        });
    }

    getUpcomingMatches(req){
        return new Promise((resolve, reject) => {
            this._verifyAuthentication(req)
            .then((ret) => {
                var conditions = [
                    new CustomCondition(() => { return this._isValidRequestParams(req); }, ApiService.INVALID_REQUEST_PARAMS()),
                    new CustomCondition(() => { return this._isValidIdUser(ret.id); }, ApiService.UNAUTHORIZED()),
                    new CustomCondition(() => { return this._isValidDatefrom(req); }, ApiService.INVALID_DATEFROM())
                ];
                var validator = new CommonValidatorHelper(conditions, () => { this._doAfterValidateGetUpcomingMatches(ret.id, req.params.datefrom, resolve, reject) }, 
                                                                     (err) => reject({ status: false, code: 400, message: err}));
                validator.execute();
            }, (ret) => reject(ret))
            .catch((err) => reject(err));
        });
    }

    _doAfterValidateLogin(username, password, resolve, reject){
        this._UserMap.findOne({username: username}, (err, userReturned) => {
            if (err){
                reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
            }else{
                if (userReturned === undefined || userReturned === null){
                    reject({ status: false , message: ApiService.INVALID_CREDENTIALS()});
                }else{
                    if (userReturned.password !== password){
                        reject({ status: false, message: ApiService.INVALID_CREDENTIALS() });
                    }else{
                        var token = this._jwt.sign({id: userReturned._id, username: userReturned.username, password: userReturned.password}, config.secret, { expiresIn: config.expiresIn });
                        resolve({ status: true, token: token });
                    }
                }
            }
        })
    }

    _doAfterValidateGetUserProfile(idUser, resolve, reject){
        this._PlayerMap.findOne({_idUser: idUser}, (err, playerReturned) => {
            if(err){
                reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
            }else{
                if (playerReturned === undefined || playerReturned === null){
                    reject({ status: false, code: 401, message: ApiService.UNAUTHORIZED() });
                }else{
                    resolve(playerReturned.profile);
                }
            }
        });
    }

    _doAfterValidateSignUp(username, password, resolve, reject){
        this._UserMap.findOne({username: username}, (err, userReturned) => {
            if (err){
                reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
            }else{
                if(userReturned !== null && userReturned !== undefined){
                    reject({ status: false, message: ApiService.USERNAME_IS_ALREADY_IN_USE() });
                }else{
                    this._createUser(username, password, resolve, reject);
                }
            }
        });
    }

    _createUser(username, password, resolve, reject){
        var user = new this._UserMap({username: username, password: password});
        user.save((err) => {
            if (err){
                reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
            }else{
                this._createPlayer(user, resolve, reject);
            }
        });
    }

    _createPlayer(user, resolve, reject){
      var player = new this._PlayerMap({
          _idUser: user._id, 
          profile: {nickname: user.username}}
          );

      player.save((err) => {
        if(err){
            reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
        }else{
          resolve(ApiService.USER_CREATED());
        }
      });
    }

    _doAfterValidateGetUpcomingMatches(idUser, datefrom, resolve, reject){
        this._PlayerMap.findOne({_idUser: idUser}, (err, playerReturned) => {
            if(err){
                reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
            }else{
                if(playerReturned === undefined || playerReturned === null){
                    reject({ status: false, code: 401, message: ApiService.UNAUTHORIZED() });
                }else{
                    this._MatchMap.find({ datetime: {$gte: new Date(datefrom).toISOString()}, confirmed: [playerReturned._id]}, 
                        (err, mathcesReturned) => {
                            if(err){
                                reject({ status: false , message: ApiService.UNEXPECTED_ERROR()});
                            }else{
                                resolve(mathcesReturned);
                            }
                        });
                }
            }
        });
    }

    _isValidRequest(req){
        return !(req === undefined || req === null);
    }

    _isValidRequestHeader(req){
        return !(req.headers === undefined || req.headers === null);
    }

    _isValidRequestBody(req){
        return !(req.body === undefined || req.body === null);
    }

    _isValidAuthorization(req){
        return !(req.headers.authorization === undefined || req.headers.authorization === null);
    }

    _verifyAuthentication(req){
        return new Promise((resolve, reject) => {
            var conditions = [
                 new CustomCondition(() => { return this._isValidRequest(req); }, ApiService.INVALID_REQUEST()),
                 new CustomCondition(() => { return this._isValidRequestHeader(req); }, ApiService.INVALID_REQUEST_HEADER()),
                 new CustomCondition(() => { return this._isValidAuthorization(req); }, ApiService.UNAUTHORIZED())
            ];
            
            var validator = new CommonValidatorHelper(conditions, () => { 
                this._jwt.verify(req.headers.authorization, config.secret, (err, decoded) => {
                    if(err){
                        reject({ status: false, code: 401, message: ApiService.UNAUTHORIZED()});
                    }else{
                        resolve(decoded);
                    }
                });
             }, (err) =>  reject({ status: false, code: 401, message: err}));
            validator.execute();
        });
    }

    _isValidUsername(req){
        return !(req.body.username === undefined || req.body.username === null);
    }

    _isValidPassword(req){
        return !(req.body.password === undefined || req.body.password === null);
    }

    _isValidRequestParams(req){
        return !(req.params === undefined || req.params === null);
    }

    _isValidDatefrom(req){
        return (!(req.params.datefrom === undefined || req.params.datefrom === null)) && moment(req.params.datefrom, [moment.ISO_8601], true).isValid();
    }

    _isValidIdUser(idUser){
        return !(idUser === undefined || idUser === null);
    }

    static UNAUTHORIZED(){
        return 'Unauthorized';
    }

    static INVALID_REQUEST(){
        return 'Request inválido';
    }

    static INVALID_REQUEST_PARAMS(){
        return 'Los parámetros del request no son válidos.';
    }

    static INVALID_REQUEST_HEADER(){
        return 'EL header no es válido.';
    }

    static INVALID_REQUEST_BODY(){
        return 'Body request inválido';
    }

    static INVALID_USERMAP(){
        return 'El USERMAP es inválido.';
    }

    static INVALID_PLAYERMAP(){
        return 'El PLAYERMAP es inválido.';
    }

    static INVALID_MATCHMAP(){
        return 'El MATCHMAP es inválido.';
    }

    static INVALID_JWT(){
        return 'El jwt es inválido';
    }

    static INVALID_CALLBACK(){
        return 'Callback inválido.';
    }

    static INVALID_CREDENTIALS(){
        return 'Las credenciales no son válidas.';
    }

    static USERNAME_IS_ALREADY_IN_USE(){
        return 'El nombre de usuario ya está siendo utilizado.';
    }

    static INVALID_ID_USER(){
        return 'El id de usuario es inválido.';
    }

    static USER_CREATED(){
        return 'El usuario ha sido creado.';
    }

    static USER_DOES_NOT_EXIST(){
        return 'Usuario inexistente.';
    }

    static UNEXPECTED_ERROR(){
        return 'Error inexperado.';
    }

    static INVALID_DATEFROM(){
        return 'El parametro datefrom debe existeir en el request.params';
    }
}

module.exports = ApiService;